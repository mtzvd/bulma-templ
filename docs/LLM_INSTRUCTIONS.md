# LLM Instructions for Bulma-Templ

This document provides guidance for LLMs working with the Bulma-Templ codebase.

## Non-Negotiable Rules for LLMs

**These rules are absolute. Violating them breaks the project philosophy.**

1. **DO NOT introduce new abstractions**
   - No helper DSLs, no enum types for Bulma classes
   - No wrapper functions around existing components
   - No "convenience" layers

2. **DO NOT redesign existing APIs**
   - If a component exists, use it as-is
   - Do not "improve" or "modernize" working code
   - Do not refactor without explicit request

3. **DO NOT add logic or state management**
   - Components render HTML, nothing more
   - No computation, validation, or transformation
   - No event handlers, no interactivity code

4. **DO NOT deviate from Bulma documentation**
   - Bulma CSS classes map 1:1 to component props
   - Any deviation from Bulma docs is a bug
   - Kitchen Sink examples are authoritative

5. **When in doubt, DO NOTHING**
   - Ask for clarification instead of inferring intent
   - If clarification is not possible, do nothing
   - Better to under-deliver than to over-engineer

## Project Overview

`Bulma-Templ` is a Go library that provides [Bulma CSS](https://bulma.io/) components as [templ](https://templ.guide/) templates. It enables type-safe, composable UI components in Go.

## Core Principles

1. **Type Safety**: All components use strongly-typed Props structs
2. **Composability**: Components accept `Items` (child content) for nesting — this is the ONLY composition model
3. **Bulma Compliance**: Bulma documentation maps 1:1 to components. Any deviation is a bug.
4. **Zero Logic**: Components render HTML; they MUST NOT compute, validate, or transform data
5. **Caller Control**: All content and behavior is fully controlled by the caller, never by the component

## Component Structure

### Standard Component Pattern

```go
// ComponentProps defines configuration for the component
type ComponentProps struct {
    Color string           // Bulma color modifier (is-primary, is-link, etc.)
    Size  string           // Bulma size modifier (is-small, is-medium, is-large)
    Attr  templ.Attributes // Additional HTML attributes
    // ... component-specific fields
}

// Component renders the Bulma component
templ Component(props ComponentProps, content Items) {
    {{
        // Build classes array
        classes := []string{"component-base-class"}
        
        if props.Color != "" {
            classes = append(classes, props.Color)
        }
        if props.Size != "" {
            classes = append(classes, props.Size)
        }
        
        // Copy attributes to avoid mutation
        attrs := templ.Attributes{}
        for k, v := range props.Attr {
            attrs[k] = v
        }
    }}
    
    @BaseElement(
        BaseElementProps{
            Tag:         "div",
            BaseClasses: classes,
            Attr:        attrs,
        },
        content,
    )
}
```

## Comment Style

See [COMMENT_STYLE.md](COMMENT_STYLE.md) for detailed guidelines.

### Key Points:
- Use `//` for all comments (never `/* */`)
- Component doc comments: `// ComponentName — Brief description.`
- Add "Atomic level: ATOM/MOLECULE/ORGANISM" after the first line
- Props struct: Explain purpose before listing fields
- Field comments: End with period, align for readability

## Critical Project Decisions (DO NOT CHANGE)

These architectural decisions are final and MUST NOT be questioned or "improved":

### Composition Model
- `Items` is the ONLY way to pass child content
- NO slots, NO named children, NO positional parameters
- `Items` accepts both `templ.Component` and raw HTML strings

### Props Design
- All props are **value types** (no pointers)
- Bulma modifiers are **plain strings** (e.g., `Color string`)
- NO enums, NO constants for class names in Props
- Special sentinel values use package-level constants (e.g., `ProgressUnset = -1`)

### CSS Helpers
- Bulma helper classes MUST remain plain strings
- They MUST NOT be wrapped, enumerated, or abstracted
- Users pass them directly as strings — this is intentional

### HTML is Expected
- Direct HTML in templates is allowed and encouraged
- Not everything needs to be a component
- Inline `<div>`, `<span>`, etc. are idiomatic

### Kitchen Sink is Authority
- `examples/kitchensink/` demonstrates correct usage
- When in doubt, check Kitchen Sink first
- It serves as both example and validation

## File Organization

```
component_name.templ       # Component implementation
component_name_templ.go    # Generated by templ (don't edit)
component_name_test.go     # Tests (if applicable)
```

## Common Patterns

### 1. Conditional Classes
```go
classes := []string{"base-class"}
if props.Modifier != "" {
    classes = append(classes, props.Modifier)
}
```

### 2. Attribute Handling
```go
attrs := templ.Attributes{}
for k, v := range props.Attr {
    attrs[k] = v
}
// Add computed attributes
attrs["data-custom"] = someValue
```

### 3. Optional Attributes
```go
const UnsetValue = -1

if props.Value != UnsetValue {
    attrs["value"] = props.Value
}
```

### 4. Content Rendering
```go
templ Component(props Props, content Items) {
    // Component can accept child content via Items
    @BaseElement(props, content)
}
```

## Testing Guidelines

- Use `render_test.go` pattern for component rendering tests
- Test component props variations
- Verify correct CSS class application
- Test attribute passing and merging

## Atomic Design Levels

- **ATOM**: Basic building blocks (Button, Input, Icon)
- **MOLECULE**: Simple groups (Field with Label and Input)
- **ORGANISM**: Complex components (Navbar, Modal)

## Common Bulma Modifiers

### Colors
- `is-primary`, `is-link`, `is-info`, `is-success`
- `is-warning`, `is-danger`, `is-dark`, `is-light`

### Sizes
- `is-small`, `is-normal`, `is-medium`, `is-large`

### States
- `is-active`, `is-focused`, `is-hovered`
- `is-loading`, `is-disabled`

## When Creating New Components

1. Check Bulma documentation for correct class names
2. Create Props struct with all configurable options
3. Follow the standard component pattern
4. Add appropriate doc comments
5. Use BaseElement for rendering when possible
6. Write tests for main variations
7. Update this documentation if introducing new patterns

## Files to Reference

- [CANONICAL_PROJECT_CONTEXT.md](CANONICAL_PROJECT_CONTEXT.md) - Project structure and patterns
- [COMMENT_STYLE.md](COMMENT_STYLE.md) - Comment formatting rules
- [CONTRIBUTING.md](../CONTRIBUTING.md) - Contribution guidelines
- [DESIGN_SYSTEM.md](DESIGN_SYSTEM.md) - Design patterns and atomic structure

## Example: Creating a New Component

**IMPORTANT**: This example shows the correct structural pattern. Do NOT add logic, state, or behavior beyond basic CSS class composition.

```go
package elements

// Badge — Bulma tag component for badges.
// Atomic level: ATOM
//
// Badge renders a small inline tag element, commonly used
// for labels, counts, or status indicators.
type BadgeProps struct {
    // Color defines the Bulma color modifier
    // (is-primary, is-info, is-success, is-warning, is-danger).
    Color string
    
    // Size defines the Bulma size modifier
    // (is-small, is-medium, is-large).
    Size string
    
    // Attr contains additional HTML attributes.
    Attr templ.Attributes
}

// Badge renders a Bulma tag element.
templ Badge(props BadgeProps, content Items) {
    {{
        classes := []string{"tag"}
        
        if props.Color != "" {
            classes = append(classes, props.Color)
        }
        if props.Size != "" {
            classes = append(classes, props.Size)
        }
        
        attrs := templ.Attributes{}
        for k, v := range props.Attr {
            attrs[k] = v
        }
    }}
    
    @BaseElement(
        BaseElementProps{
            Tag:         "span",
            BaseClasses: classes,
            Attr:        attrs,
        },
        content,
    )
}
```

**Why this example**: Simple, atomic, no conditional logic, uses BaseElement, purely presentational.

## Common Mistakes to Avoid

### CRITICAL Mistakes (Project-Breaking)

1. **NEVER mutate input props**: Always copy `Attr` before modification
2. **NEVER compute values**: Components render; callers compute
3. **NEVER create enums for Bulma classes**: Use plain strings
4. **NEVER add abstractions**: No DSLs, no wrappers, no "helper builders"
5. **NEVER deviate from Bulma**: Follow exact class names from Bulma docs

### Important Mistakes (Code Quality)

6. **Don't use magic numbers**: Use constants for sentinel values (e.g., `ProgressUnset = -1`)
7. **Don't skip doc comments**: Every component and field needs documentation
8. **Don't add behavior**: No event handlers, no state management
9. **Don't "improve" working code**: If it works and follows patterns, leave it alone
10. **Don't infer requirements**: Ask instead of assuming

### LLM-Specific Warnings

- **Stop "helpfully" refactoring** — this isn't helpfulness, it's harm
- **Stop suggesting "best practices" from other ecosystems** — Bulma-Templ has its own philosophy
- **Stop trying to make code "more idiomatic"** — it already is, for this project
- **Stop proposing type-safe alternatives** — strings are the choice, not a limitation

## Build Commands

- `templ generate` - Generate Go code from .templ files
- `go test ./...` - Run all tests
- `go build ./cmd/dev` - Build development server

## Additional Resources

- [Bulma Documentation](https://bulma.io/documentation/)
- [templ Documentation](https://templ.guide/)
- [Go Templates Best Practices](https://pkg.go.dev/github.com/a-h/templ)
