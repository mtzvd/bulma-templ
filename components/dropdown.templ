package components

import "github.com/mtzvd/bulma-templ/elements"

// Dropdown renders a Bulma `.dropdown` component.
// Atomic level: ORGANISM
//
// Dropdown defines composite UI component used to display
// contextual menus. It does not manage state or behavior;
// state must be controlled externally (e.g. via Alpine.js).
type DropdownProps struct {
	// Active applies the `is-active` modifier.
	Active bool

	// Hoverable enables hover-based activation (`is-hoverable`).
	Hoverable bool

	// Right aligns the dropdown menu to the right (`is-right`).
	Right bool

	// Up opens the dropdown upwards (`is-up`).
	Up bool

	// Attr contains additional HTML attributes
	// for the `.dropdown` container.
	Attr templ.Attributes
}

// Dropdown renders the root `.dropdown` container.
templ Dropdown(props DropdownProps, content elements.Items) {
	{{
		classes := []string{"dropdown"}

		if props.Active {
			classes = append(classes, "is-active")
		}
		if props.Hoverable {
			classes = append(classes, "is-hoverable")
		}
		if props.Right {
			classes = append(classes, "is-right")
		}
		if props.Up {
			classes = append(classes, "is-up")
		}
	}}

	@elements.BaseElement(
		elements.BaseElementProps{
			Tag:         "div",
			BaseClasses: classes,
			Attr:        props.Attr,
		},
		content,
	)
}

// DropdownTrigger renders `.dropdown-trigger`.
// Atomic level: MOLECULE
//
// DropdownTrigger is used to render the trigger element
// (button, link, etc.) that controls the dropdown state.
type DropdownTriggerProps struct {
	// Attr contains additional HTML attributes
	// for the `.dropdown-trigger` container.
	Attr templ.Attributes
}

// DropdownTrigger renders a Bulma `.dropdown-trigger`.
templ DropdownTrigger(props DropdownTriggerProps, content elements.Items) {
	
	@elements.BaseElement(
		elements.BaseElementProps{
			Tag: "div",
			BaseClasses: []string{"dropdown-trigger"},
			Attr: props.Attr,
		},
		content,
	)
}


// DropdownMenu renders `.dropdown-menu` and `.dropdown-content`.
// Atomic level: MOLECULE
//
// DropdownMenu wraps dropdown items and does not manage state.
type DropdownMenuProps struct {
	// Attr contains additional HTML attributes
	// for the `.dropdown-menu` container.
	Attr templ.Attributes
}

// DropdownMenu renders a Bulma dropdown menu container.
templ DropdownMenu(props DropdownMenuProps, content elements.Items) {
	@elements.BaseElement(
		elements.BaseElementProps{
			Tag:         "div",
			BaseClasses: []string{"dropdown-menu"},
			Attr:        props.Attr,
		},
		elements.Items{
			elements.BaseElement(
				elements.BaseElementProps{
					Tag:         "div",
					BaseClasses: []string{"dropdown-content"},
				},
				content,
			),
		},
	)
}

// DropdownDivider renders a Bulma `.dropdown-divider`.
// Atomic level: ATOM
//
// Used to visually separate dropdown items.
templ DropdownDivider() {
	@elements.BaseElement(
		elements.BaseElementProps{
			Tag:         "hr",
			BaseClasses: []string{"dropdown-divider"},
		},
		nil,
	)
}



// DropdownItem renders a Bulma `.dropdown-item`.
// Atomic level: ATOM
//
// DropdownItem is always rendered as an <a> element.
// If Href is empty, the item is treated as an action item
// and can be handled via JS/Alpine.
type DropdownItemProps struct {
	// Href defines the link URL.
	// If empty, the item is treated as an action item.
	Href string

	// Active applies the `is-active` modifier.
	Active bool

	// Attr contains additional HTML attributes
	// for the item element.
	Attr templ.Attributes
}

// DropdownItem renders a Bulma `.dropdown-item`.
templ DropdownItem(props DropdownItemProps, content elements.Items) {
	{{
		classes := []string{"dropdown-item"}
		if props.Active {
			classes = append(classes, "is-active")
		}

		attrs := templ.Attributes{}
		for k, v := range props.Attr {
			attrs[k] = v
		}

		if props.Href != "" {
			attrs["href"] = props.Href
		}
	}}

	@elements.BaseElement(
		elements.BaseElementProps{
			Tag:         "a",
			BaseClasses: classes,
			Attr:        attrs,
		},
		content,
	)
}

